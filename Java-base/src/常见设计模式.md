### 创建型模式
- 简单工厂模式
  - *简单地说，简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。*
- 工厂模式
  - 简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。
  - 其实就是一个工厂接口多个工厂实现
- 抽象工厂模式
- 当涉及到产品族的概念时，就需要引入抽象工厂模式了
- 一个经典的例子是造一台电脑。因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，但是它们可能会有兼容问题
- 当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了对修改关闭，对扩展开放这个设计原则。
- 单例模式
> 单例就是私有构造器+私有静态实例+公共静态方法返回实例
    - 饿汉模式：先创建对象，缺点是它会先创建对象
  ```java
    
  public class Singleton {
  // 首先，将 new Singleton() 堵死
  private Singleton() {};
  // 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建
  private static Singleton instance = new Singleton();

  public static Singleton getInstance() {
      return instance;
  }
  // 瞎写一个静态方法。这里想说的是，如果我们只是要调用 Singleton.getDate(...)，
  // 本来是不想要生成 Singleton 实例的，不过没办法，已经生成了
  public static Date getDate(String mode) {return new Date();}
  }
  ```
- 饱汉模式：先给null，不创建对象，实例化再创建
  ```java
    public class Singleton {
     // 首先，也是先堵死 new Singleton() 这条路
     private Singleton() {}
     // 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的
     private static volatile Singleton instance = null;

     public static Singleton getInstance() {
       if (instance == null) {
         // 加锁
         synchronized (Singleton.class) {
           // 这一次判断也是必须的，不然会有并发问题
           if (instance == null) {
          instance = new Singleton();
          }
        }
      }
      return instance;
    }
  }
  ```
  - 嵌套类
  ```java
  public class Singleton3 {

    private Singleton3() {}
    // 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性
    private static class Holder {
        private static Singleton3 instance = new Singleton3();
    }
    public static Singleton3 getInstance() {
        return Holder.instance;
    }
  }
  ```
  - 枚举
  > 枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。
- 建造者模式
> 其实就是静态内部类设置值并返回本身，添加build方法复制值到最终对象
- 原型模式
>原型模式很简单：有一个原型实例，基于这个原型实例产生新的实例，也就是“克隆”了。
>java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。
#### 总结：创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是面向对象的代码，所以我们第一步当然是要创建对象了。简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂有产品族的概念，如果各个产品有兼容性问题，就要用抽象工厂模式。单例模式就不用说了，为了保证全局使用的是同以对象，一方面是安全性考虑，一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用的少，了解和Object类中的clone（）方法相关的知识即可
### 结构型模式
- 代理模式
> 代理类实现接口，并在代理类内部又一个真实的实现类。就是为类隐藏真实实现
- 适配器模式
> 适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配。
- 桥梁模式
> 理解桥梁模式，其实就是理解代码抽象和解耦。
> 桥梁模式就是接口+实现+抽象类+子类继承抽象类
- 装饰模式
> 装饰器模式就是用具体的装饰器来装饰实现类，以达到增强的目的。
> 从名字来简单解释下装饰器。既然说是装饰，那么往往就是添加小功能这种，而且，我们要满足可以添加多个小功能。最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的多层包装方式，但是那样的话代码就复杂了。
- 门面模式
> 又叫外观模式，经典实现就是slf4j了
> 简单来说就是创建门面类，提供所有对象的实例化
> 门面模式的优点显而易见，客户端不再需要关注实例化时应该使用哪个实现类，直接调用门面提供的方法就可以了，因为门面类提供的方法的方法名对于客户端来说已经很友好了。
- 组合模式
> 组合模式用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。
- 享元模式
>英文是 Flyweight Pattern，不知道是谁最先翻译的这个词，感觉这翻译真的不好理解，我们试着强行关联起来吧。Flyweight 是轻量级的意思，享元分开来说就是 共享 元器件，也就是复用已经生成的对象，这种做法当然也就是轻量级的了。
> 复用对象最简单的方式是，用一个 HashMap 来存放每次新生成的对象。每次需要一个对象的时候，先到 HashMap 中看看有没有，如果没有，再生成新的对象，然后将这个对象放入 HashMap 中。
#### 总结：代理模式是做方法增强的；适配器模式是把鸡包装成鸭这种用来适配接口的；桥梁模式做到了很好的解耦；装饰器模式从名字可以看出来，适用于装饰类或者增强类的场景；门面模式的有点是客户端不需要关心实例化过程，只要调用需要的方法即可；组合模式用于描述具有层次结构的数据；享元模式是为了在特定的场景缓存已经创建的对象，用于提高性能
### 行为型模式
- 策略模式
> 定义策略接口+实现+使用策略的类 context，内部持有策略接口（构造器初始化），指定实现相应功能。与桥梁模式类似
- 观察者模式
> 无外乎两个操作，观察者订阅自己关心的主题和主题有数据变化后通知观察者们。
> 所以关键实现包含一个Subject（主题），主题的功能包含：通知观察者（遍历），注册观察者，状态变更；然后就是观察接口以及实现。观察者通过构造方法订阅主题，然后提供数据变更方法
> 实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。
> 还有，即使是上面的这个代码，也会有很多变种，大家只要记住核心的部分，那就是一定有一个地方存放了所有的观察者，然后在事件发生的时候，遍历观察者，调用它们的回调函数。
- 责任链模式
> 责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了。
> 其实现的话先定义流程上节点的基类，基类持有后继节点。接着定义具体的每个节点，定义关键方法apply持有规则对象，然后判断并一直传递下去。
- 模版方法模式
> 模版方法本质就是有一个抽象类定义所有方法。它只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。
- 状态模式
>我的理解是跟对象状态相关的逻辑抽象出来，只做对象状态的变更逻辑。而另一个类Context只操作对象本身，这也算是一种解耦吧
#### 总结：策略模式与桥梁模式类似；观察者模式其实就是观察者订阅自己关心的主题和主题有数据变化后通知观察者们；责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去；在含有继承结构的代码中，模板方法模式是非常常用的。

